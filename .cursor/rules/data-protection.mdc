---
description: "Data Protection Rules - Never Lose Enriched Lead Data"
alwaysApply: true
globs:
  - "brainscraper/app/api/**"
  - "brainscraper/utils/**"
  - "brainscraper/app/enriched/**"
---

# Data Protection Rules - CRITICAL

## âš ï¸ ABSOLUTE PRIORITY: NEVER OVERWRITE OR LOSE ENRICHED DATA

### Core Principle
**Enriched lead data represents significant financial investment (API costs). Every lead in the database or `enriched-all-leads.json` is valuable and must be preserved at all costs.**

---

## ðŸš« MANDATORY RULES

### 1. NEVER Overwrite Existing Leads
- The aggregation endpoint (`/api/aggregate-enriched-leads`) MUST merge leads, never replace
- Always load existing leads FIRST before adding new ones
- Use deduplication keys:
  - Primary: `linkedinUrl` (unique)
  - Fallback: `name + email + phone` (composite key)
- Preserve existing data when merging (prefer existing if new is empty)

**Correct Pattern:**
```typescript
// âœ… CORRECT: Load first, then merge
const existingLeads = await loadExistingLeads();
const mergedLeads = mergeLeads(existingLeads, newLeads);
await saveLeads(mergedLeads);

// âŒ WRONG: Direct overwrite
await saveLeads(newLeads); // LOSES EXISTING DATA!
```

### 2. NEVER Delete Data Files
- `enriched-all-leads.json` is the single source of truth
- Never truncate, clear, or reset this file
- Never delete individual lead files in `data/enriched-leads/`
- PostgreSQL `leads` table is permanent storage - never truncate

### 3. Always Verify Before Writing
- Check that existing leads are loaded before aggregation
- Verify file locking is in place for concurrent writes
- Use atomic writes (temp file + rename) for safety
- Use PostgreSQL transactions for database writes

**Correct Pattern:**
```typescript
// âœ… CORRECT: Atomic write
const tempFile = `${targetFile}.tmp`;
fs.writeFileSync(tempFile, JSON.stringify(data));
fs.renameSync(tempFile, targetFile);
```

### 4. Filtering Must Be Additive, Not Destructive
- When filtering leads (e.g., age > 59), filter BEFORE saving, not after
- Filtering should prevent new leads from being added, not remove existing ones
- Existing leads in database/JSON should remain untouched by filters
- Filters apply to NEW leads only, not existing data

**Correct Pattern:**
```typescript
// âœ… CORRECT: Filter before saving
const validLeads = newLeads.filter(lead => lead.age <= 59);
await saveLeads(validLeads); // Only valid leads saved

// âŒ WRONG: Filter after saving
await saveLeads(newLeads);
const validLeads = allLeads.filter(lead => lead.age <= 59); // Removes existing!
```

### 5. Code Changes Must Be Read-Only for Data
- Formatting functions (CSV export) must never touch data files
- UI changes must never modify server-side data
- API route changes must preserve existing data structure
- Migration scripts must be backward compatible

### 6. Deployment Safety
- Railway persistent volumes are separate from code deployments
- Code changes cannot affect `/data` volume
- Always verify data persistence across deployments
- Database migrations must be reversible

---

## ðŸ” RED FLAGS (STOP and Verify)

If you see any of these patterns, **STOP** and fix immediately:

- âŒ Any code that writes to `enriched-all-leads.json` without loading existing data first
- âŒ Any code that clears, truncates, or resets data files
- âŒ Any code that filters existing leads from the database (should only filter new leads)
- âŒ Any code that modifies data structure without backward compatibility
- âŒ Any `fs.writeFileSync()` without checking for existing data
- âŒ Any `DELETE FROM leads` or `TRUNCATE TABLE leads` queries
- âŒ Any filtering that removes existing leads (should only prevent new bad leads)

---

## âœ… SUCCESS CRITERIA

After any change, verify:
- âœ… Existing leads remain intact
- âœ… New leads are merged, not replaced
- âœ… Filters prevent new bad leads, don't remove existing leads
- âœ… Data files are never deleted or truncated
- âœ… All changes are additive or read-only
- âœ… Database records are never deleted (only marked as inactive if needed)

---

## ðŸ“‹ DEDUPLICATION STRATEGY

### Primary Key: LinkedIn URL
```typescript
const existingMap = new Map(
  existingLeads.map(lead => [lead.linkedinUrl, lead])
);

for (const newLead of newLeads) {
  const existing = existingMap.get(newLead.linkedinUrl);
  if (existing) {
    // Merge: prefer existing data, fill gaps with new data
    mergedLeads.push({ ...existing, ...newLead });
  } else {
    mergedLeads.push(newLead);
  }
}
```

### Fallback Key: Name + Email + Phone
```typescript
const key = `${name}:${email}:${phone}`;
if (existingKeys.has(key)) {
  // Skip duplicate
} else {
  existingKeys.add(key);
  mergedLeads.push(newLead);
}
```

---

## ðŸ›¡ï¸ PROTECTION PATTERNS

### Pattern 1: Load-Merge-Save
```typescript
async function addLeads(newLeads: Lead[]) {
  // 1. Load existing
  const existing = await loadLeads();
  
  // 2. Merge (never replace)
  const merged = mergeLeads(existing, newLeads);
  
  // 3. Save merged result
  await saveLeads(merged);
}
```

### Pattern 2: Atomic Database Write
```typescript
async function saveLead(lead: Lead) {
  await pool.query(`
    INSERT INTO leads (linkedin_url, name, ...)
    VALUES ($1, $2, ...)
    ON CONFLICT (linkedin_url) 
    DO UPDATE SET 
      name = COALESCE(leads.name, EXCLUDED.name),
      phone = COALESCE(leads.phone, EXCLUDED.phone)
  `, [lead.linkedinUrl, lead.name, ...]);
}
```

### Pattern 3: Filter Before Save
```typescript
async function processLeads(rawLeads: Lead[]) {
  // Filter BEFORE saving
  const validLeads = rawLeads.filter(lead => {
    return lead.age <= 59 && 
           lead.canContact === true &&
           lead.phone && lead.phone.length >= 10;
  });
  
  // Only save valid leads
  await addLeads(validLeads);
}
```

---

## ðŸš¨ WHEN IN DOUBT

- **ASK:** If unsure about data safety, ask before implementing
- **BACKUP:** Suggest backup before any data-modifying changes
- **VERIFY:** Always verify that existing leads are preserved after changes
- **TEST:** Test with small datasets before applying to production
- **REVIEW:** Check existing code patterns in `app/enriched/` and `app/api/` for examples
