import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

/**
 * The Dojo - Spider Deployment API
 * 
 * Deploys generated spiders to GitHub and registers them for monitoring.
 * 
 * Flow:
 * 1. Generate spider code from blueprint
 * 2. Push to GitHub (scrapegoat/app/scraping/spiders/)
 * 3. Register spider for health monitoring
 * 4. Update site config with deployment info
 */

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_REPO = process.env.GITHUB_REPO || 'linkpellow/my-lead-engine';
const GITHUB_BRANCH = process.env.GITHUB_BRANCH || 'main';
const SPIDERS_PATH = 'scrapegoat/app/scraping/spiders';

interface DeployRequest {
  domain: string;
  spiderId: string;
  filename: string;
  code: string;
  blueprintId?: string;
  commitMessage?: string;
  // Blueprint fields (optional - for pattern-driven extraction)
  targetUrl?: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  headers?: Record<string, string>;
  body?: any;
  extraction?: Record<string, string>; // field_name -> json_path mapping
  dynamicParams?: string[];
}

interface DeployResult {
  success: boolean;
  spiderId: string;
  filename: string;
  githubUrl?: string;
  commitSha?: string;
  error?: string;
}

/**
 * Generate complete spider code from blueprint
 */
function generateSpiderCode(blueprint: {
  id: string;
  filename: string;
  targetUrl: string;
  method: string;
  headers: Record<string, string>;
  body?: unknown;
  pydanticModels: string;
  extractionLogic: string;
  dynamicParams: string[];
}): string {
  const className = blueprint.id
    .split('_')
    .map(w => w.charAt(0).toUpperCase() + w.slice(1))
    .join('') + 'Spider';
  
  const headersStr = Object.entries(blueprint.headers)
    .map(([k, v]) => `        "${k}": "${v}"`)
    .join(',\n');
  
  return `"""
${className} - Auto-generated by The Dojo
Generated at: ${new Date().toISOString()}
Target: ${blueprint.targetUrl}
"""

import os
import json
from typing import Optional, List, Dict, Any
from datetime import datetime

# Pydantic models for response parsing
${blueprint.pydanticModels}

class ${className}:
    """
    Spider for ${blueprint.id}
    Method: ${blueprint.method}
    """
    
    name = "${blueprint.id}"
    target_url = "${blueprint.targetUrl}"
    method = "${blueprint.method}"
    
    # Dynamic parameters that can be passed at runtime
    dynamic_params = ${JSON.stringify(blueprint.dynamicParams)}
    
    def __init__(self, **kwargs):
        self.session = None
        self.params = kwargs
        self.results = []
        self.errors = []
        
    def get_headers(self) -> Dict[str, str]:
        """Return headers for the request"""
        return {
${headersStr}
        }
    
    def get_url(self, **params) -> str:
        """Build URL with dynamic parameters"""
        url = self.target_url
        for param, value in params.items():
            url = url.replace("{" + param + "}", str(value))
        return url
    
    ${blueprint.body ? `def get_body(self, **params) -> Dict[str, Any]:
        """Return request body"""
        body = ${JSON.stringify(blueprint.body, null, 8)}
        # Apply any dynamic params to body
        return body
    ` : ''}
    async def run(self, **params) -> List[Dict[str, Any]]:
        """Execute the spider"""
        import httpx
        
        url = self.get_url(**params)
        headers = self.get_headers()
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                if self.method == "GET":
                    response = await client.get(url, headers=headers)
                else:
                    body = self.get_body(**params) if hasattr(self, 'get_body') else None
                    response = await client.post(url, headers=headers, json=body)
                
                response.raise_for_status()
                data = response.json()
                
                # Extract data using generated logic
                self.results = self.extract(data)
                return self.results
                
        except Exception as e:
            self.errors.append(str(e))
            raise
    
    def extract(self, data: Any) -> List[Dict[str, Any]]:
        """Extract structured data from response"""
        results = []
        ${blueprint.extractionLogic.split('\n').map(line => '        ' + line).join('\n')}
        return results


# For direct execution
if __name__ == "__main__":
    import asyncio
    
    spider = ${className}()
    results = asyncio.run(spider.run())
    print(json.dumps(results, indent=2))
`;
}

/**
 * Push file to GitHub using REST API
 */
async function pushToGitHub(
  filename: string,
  content: string,
  message: string
): Promise<{ success: boolean; sha?: string; url?: string; error?: string }> {
  if (!GITHUB_TOKEN) {
    return { success: false, error: 'GITHUB_TOKEN not configured' };
  }
  
  const filePath = `${SPIDERS_PATH}/${filename}`;
  const apiUrl = `https://api.github.com/repos/${GITHUB_REPO}/contents/${filePath}`;
  
  try {
    // Check if file exists (to get current SHA for update)
    let existingSha: string | undefined;
    try {
      const checkResponse = await fetch(apiUrl, {
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
        },
      });
      if (checkResponse.ok) {
        const existing = await checkResponse.json();
        existingSha = existing.sha;
      }
    } catch {
      // File doesn't exist, that's fine
    }
    
    // Create or update file
    const response = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message,
        content: Buffer.from(content).toString('base64'),
        branch: GITHUB_BRANCH,
        ...(existingSha && { sha: existingSha }),
      }),
    });
    
    if (!response.ok) {
      const error = await response.text();
      return { success: false, error: `GitHub API error: ${response.status} - ${error}` };
    }
    
    const result = await response.json();
    return {
      success: true,
      sha: result.commit?.sha,
      url: result.content?.html_url,
    };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}

/**
 * POST /api/dojo/deploy
 * Deploy a spider to GitHub
 */
export async function POST(request: NextRequest) {
  try {
    const body: DeployRequest = await request.json();
    
    if (!body.domain || !body.spiderId || !body.filename || !body.code) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: domain, spiderId, filename, code' },
        { status: 400 }
      );
    }
    
    // Push to GitHub
    const commitMessage = body.commitMessage || 
      `[Dojo] Deploy spider: ${body.spiderId} for ${body.domain}`;
    
    const githubResult = await pushToGitHub(body.filename, body.code, commitMessage);
    
    if (!githubResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: githubResult.error,
          spiderId: body.spiderId,
          filename: body.filename,
        },
        { status: 500 }
      );
    }
    
    // Save blueprint for pattern-driven extraction (if extraction paths provided)
    if (body.extraction && body.targetUrl && body.method) {
      try {
        const blueprintResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/dojo/blueprints`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            domain: body.domain,
            blueprint: {
              id: body.spiderId,
              targetUrl: body.targetUrl,
              method: body.method,
              headers: body.headers || {},
              body: body.body,
              extraction: body.extraction, // field_name -> json_path mapping
              dynamicParams: body.dynamicParams || ['name', 'city', 'state', 'zipcode'],
            },
          }),
        });
        
        if (blueprintResponse.ok) {
          console.log(`âœ… Blueprint saved for ${body.domain}`);
        }
      } catch (error) {
        console.warn('[Deploy] Failed to save blueprint (non-fatal):', error);
      }
    }
    
    // Update site config with deployment info
    const siteResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/dojo/sites`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        domain: body.domain,
        addSpider: {
          id: body.spiderId,
          filename: body.filename,
          githubUrl: githubResult.url,
          commitSha: githubResult.sha,
          deployedAt: Date.now(),
          health: 100,
          healthStatus: 'unknown',
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          monitoringEnabled: true,
          runHistory: [],
        },
      }),
    });
    
    const result: DeployResult = {
      success: true,
      spiderId: body.spiderId,
      filename: body.filename,
      githubUrl: githubResult.url,
      commitSha: githubResult.sha,
    };
    
    return NextResponse.json(result);
  } catch (error) {
    console.error('[Dojo Deploy] Error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Deployment failed',
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/dojo/deploy
 * Check deployment status / configuration
 */
export async function GET() {
  return NextResponse.json({
    configured: !!GITHUB_TOKEN,
    repo: GITHUB_REPO,
    branch: GITHUB_BRANCH,
    spidersPath: SPIDERS_PATH,
  });
}
